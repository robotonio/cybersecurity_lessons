# Challenge 4 â€“ Self Overflow & Payload Generation ğŸ§ 

## ğŸ“˜ Î Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î±: ÎˆÎ½Î± Ï€ÏÏŒÎ³ÏÎ±Î¼Î¼Î± Ï€Î¿Ï… ÎºÎ¬Î½ÎµÎ¹ overflow ÏƒÏ„Î¿Î½ ÎµÎ±Ï…Ï„ÏŒ Ï„Î¿Ï…

Î£Îµ Î±Ï…Ï„ÏŒ Ï„Î¿ Ï€Î±ÏÎ¬Î´ÎµÎ¹Î³Î¼Î±, Î¸Î± Î´Î¿ÏÎ¼Îµ Ï€ÏÏ‚ Î­Î½Î± C Ï€ÏÏŒÎ³ÏÎ±Î¼Î¼Î± Î¼Ï€Î¿ÏÎµÎ¯ **Î¼ÏŒÎ½Î¿ Ï„Î¿Ï…**, Ï‡Ï‰ÏÎ¯Ï‚ ÎµÎ¯ÏƒÎ¿Î´Î¿ Î±Ï€ÏŒ Ï„Î¿Î½ Ï‡ÏÎ®ÏƒÏ„Î·, Î½Î± Ï€ÏÎ¿ÎºÎ±Î»Î­ÏƒÎµÎ¹ **buffer overflow** ÎºÎ±Î¹ Î½Î± ÎºÎ±Ï„ÎµÏ…Î¸ÏÎ½ÎµÎ¹ Ï„Î· ÏÎ¿Î® Ï„Î¿Ï… Ï€ÏÎ¿Î³ÏÎ¬Î¼Î¼Î±Ï„Î¿Ï‚ ÏƒÎµ Î¼Î¹Î± Î´Î¹Î±Ï†Î¿ÏÎµÏ„Î¹ÎºÎ® ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ·.

---

## ğŸ” ÎšÏÎ´Î¹ÎºÎ±Ï‚: `self_overflow.c`

```c
#include <stdio.h>
#include <string.h>
#include <stdint.h>

// Î£Ï…Î½Î¬ÏÏ„Î·ÏƒÎ·-ÏƒÏ„ÏŒÏ‡Î¿Ï‚ Ï€Î¿Ï… Î´ÎµÎ½ ÎºÎ±Î»ÎµÎ¯Ï„Î±Î¹ Ï€Î¿Ï„Î­ Î±Ï€ÎµÏ…Î¸ÎµÎ¯Î±Ï‚
void secret() {
    printf("ğŸ‰ ÎœÏ€Î®ÎºÎµÏ‚ ÏƒÏ„Î· secret()!\n");
}

// Î£Ï…Î½Î¬ÏÏ„Î·ÏƒÎ· Î¼Îµ ÎµÏ…Ï€Î¬Î¸ÎµÎ¹Î± buffer overflow
void vuln() {
    char buf[32];

    // Î’ÏÎ¯ÏƒÎºÎ¿Ï…Î¼Îµ Ï„Î· Î´Î¹ÎµÏÎ¸Ï…Î½ÏƒÎ· Ï„Î·Ï‚ secret()
    uintptr_t addr = (uintptr_t)secret;

    // Î¦Ï„Î¹Î¬Ï‡Î½Î¿Ï…Î¼Îµ Ï„Î¿ payload: 40 bytes Î¼Î­Ï‡ÏÎ¹ Ï„Î¿ return address
    char payload[48];
    memset(payload, 'A', 40);              // Î£Ï…Î¼Ï€Î»Î·ÏÏÎ½Î¿Ï…Î¼Îµ buf (32) + RBP (8)
    memcpy(payload + 40, &addr, 8);        // Î‘Î½Ï„Î¹Î³ÏÎ¬Ï†Î¿Ï…Î¼Îµ Ï„Î· Î´Î¹ÎµÏÎ¸Ï…Î½ÏƒÎ· Ï„Î·Ï‚ secret()

    // Î ÏÎ¿ÎºÎ±Î»Î¿ÏÎ¼Îµ Ï„Î¿ overflow
    strcpy(buf, payload);
}

int main() {
    vuln();
    printf("âŒ Î”ÎµÎ½ Î¼Ï€Î®ÎºÎµÏ‚ ÏƒÏ„Î· secret().\n");
    return 0;
}

